# 1. 栈

列表是一种最自然的数据组织方式。上一章已经介绍如何使用List 类将数据组织成一个列表。如果数据存储的顺序不重要，也不必对数据进行查找，那么列表就是一种再好不过的数据结构。对于其他一些应用，列表就显得太过简陋了，我们需要某种和列表类似但是更复杂的数据结构。

栈就是和列表类似的一种数据结构，它可用来解决计算机世界里的很多问题。栈是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现。栈的使用遍布程序语言实现的方方面面，从表达式求值到处理函数调用。

## 1.1. 栈ADT

栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。咖啡厅内的一摞盘子是现实世界中常见的栈的例子。只能从最上面取盘子，盘子洗净后，也只能摞在这一摞盘子的最上面。栈被称为一种后入先出（LIFO，last-in-first-out）的数据结构。由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。

对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用 push() 方法，出栈使用 pop() 方法。

另一个常用的操作是预览栈顶的元素。pop() 方法虽然可以访问栈顶的元素，但是调用该方法后，栈顶元素也从栈中被永久性地删除了。peek() 方法则只返回栈顶元素，而不删除它。

为了记录栈顶元素的位置，同时也为了标记哪里可以加入新元素，我们使用变量 top，当向栈内压入元素时，该变量增大；从栈内弹出元素时，该变量减小。

push()、pop() 和 peek() 是栈的 3 个主要方法，但是栈还有其他方法和属性。clear() 方法清除栈内所有元素，length 属性记录栈内元素的个数。我们还定义了一个 isEmpty 属性，用以表示栈内是否含有元素，不过使用length 属性也可以达到同样的目的。

## 1.2. 实现栈

```javascript
class Stack {
  constructor() {
    this.size = 0;
  }

  push(ele) {
    this[this.size] = ele;
    this.size++;
    return this;
  }

  pop() {
    const elePoped = this[this.size - 1];
    delete this[this.size - 1];
    this.size--;
    return elePoped;
  }

  peek() {
    return this[this.size - 1];
  }

  clear() {
    for (let i = 0; i < this.size; i++) {
      delete this[i];
    }

    this.size = 0;

    return this;
  }

  isEmpty() {
    return this.size === 0;
  }
}
```

## 1.3. 使用栈

```javascript
const stack = new Stack();
stack.push('apple').push('orange').push('pear');
console.log(stack);
// -> Stack { '0': 'apple', '1': 'orange', '2': 'pear', size: 3 }

console.log(stack.peek());
// -> 'pear'

console.log(stack.pop());
// -> 'pear'

console.log(stack);
// -> Stack { '0': 'apple', '1': 'orange', size: 2 }

console.log(stack.isEmpty());
// -> false

console.log(stack.clear());
// -> Stack { size: 0 }
```