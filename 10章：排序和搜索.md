## 1. 简介

假设我们有一个没有任何排列顺序的电话号码簿（或笔记本）。当需要添加联络人和电话时，你只能将其写在下一个空位上。假定你的联系人列表上有很多人。某天，你要找某个联系人及其电话号码。但是由于联系人列表没有按照任何顺序来组织，你只能逐个检查，直到找到那个你想要的联系人为止。这个方法太吓人了，难道你不这么认为吗？想象一下你要在黄页上搜寻一个联系人，但是那本黄页没有进行任何组织，那得花多长时间啊？！

因此（还有其他原因），我们需要组织信息集，比如那些存储在数据结构里的信息。排序和搜索算法广泛地运用在待解决的日常问题中。

本章，你会学到最常用的排序和搜索算法，如冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、计数排序、桶排序、基数排序，以及顺序搜索、内插搜索和二分搜索算法。

## 2. 排序算法

### 2.1. 冒泡排序

人们开始学习排序算法时，通常都先学冒泡算法，因为它在所有排序算法中最简单。然而，从运行时间的角度来看，冒泡排序是最差的一个，接下来你会知晓原因。

冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。

```javascript
Array.prototype.bubbleSort = function bubbleSort() {
  const len = this.length;

  for (let round = 0; round < len - 1; round += 1) {
    for (let i = 0; i < len - 1 - round; i += 1) {
      if (this[i] > this[i + 1]) [this[i], this[i + 1]] = [this[i + 1], this[i]];
    }
  }

  return this;
};
```

```javascript
// 使用了 generate() 和 shuffle()
const input = Array.generate(10, (i) => i).shuffle();
console.log(...input);
input.bubbleSort();
console.log(...input);
// -> 5 4 6 7 1 9 8 2 0 3
// -> 0 1 2 3 4 5 6 7 8 9
```

### 2.2. 选择排序

选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值，并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。

```javascript
Array.prototype.selectionSort = function selectionSort() {
  const len = this.length;

  for (let i = 0; i < len - 1; i += 1) {
    let minIndex = i;

    for (let j = i + 1; j < len; j += 1) {
      if (this[minIndex] > this[j]) minIndex = j;
    }

    [this[i], this[minIndex]] = [this[minIndex], this[i]];
  }

  return this;
};
```

```javascript
// 使用了 generate() 和 shuffle()
const input = Array.generate(10, (i) => i).shuffle();
console.log(...input);
input.selectionSort();
console.log(...input);
// -> 6 1 9 2 3 7 4 8 0 5
// -> 0 1 2 3 4 5 6 7 8 9
```

### 2.3. 插入排序

插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推。

插入排序是符合直觉的一种排序，因为这种排序算法和我们打扑克牌时一般使用的排序一样。

```javascript
Array.prototype.insertionSort = function insertionSort() {
  const len = this.length;

  for (let i = 1; i < len; i += 1) {
    const takeInhand = this[i];

    let j = 0;

    while (j > 0 && this[i] < this[i - 1]) {
      this[j] = this[j - 1];
      j--;
    }

    this[j] = takeInhand;
  }

  return this;
};
```

```javascript
// 使用了 generate() 和 shuffle()
const input = Array.generate(10, (i) => i).shuffle();
console.log(...input);
input.selectionSort();
console.log(...input);
// -> 4 5 6 3 1 9 8 0 2 7
// -> 0 1 2 3 4 5 6 7 8 9
```

### 2.4. 归并排序

归并排序是第一个可以实际使用的排序算法。你在本书中学到的前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。

归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。

由于是分治法，归并排序也是递归的。我们要将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。我们来看看在这里声明的主要函数。

```javascript

```

### 2.5. 快速排序

### 2.6. 计数排序

### 2.7. 桶排序

### 2.8. 基数排序

## 3. 搜索算法

### 3.1. 顺序搜索

### 3.2. 二分搜索

### 3.3. 内插搜索
