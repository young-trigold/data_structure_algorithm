# 1. 数组

对于 **数组(Array)** 这个数据结构的定义是: 一种存储数据元素的线性的集合，且元素可以通过整数索引访问。数组是一种非常普遍的数据结构，几乎每种编程语言都有。

## 1.1. 简介

1. 由对象实现

在 JavaScript 中，数组实际上是由对象来实现的。来看下面这个例子。

```javascript
const trueArray = ['html', 'css', 'javascript'];
const fakeArray = {
  0: 'html',
  1: 'css',
  2: 'javascript',
};

console.log(trueArray[2]);
// -> 'javascript'

console.log(fakeArray[1]);
// -> 'css'
```

如果不看 `fakeArray` 的具体实现，我们实际上是不知道 `fakeArray` 和 `trueArray` 的区别的。

由对象实现的 JavaScript 数组在效率上没有其他语言中的高。

2. 松散类型

JavaScript 的类型系统是松散的，在语法上不要求数组内的各个元素类型相同。来看下面的例子。

```javascript
const integers = [1, 2, 3];
const items = [undefined, null, false, -1, '', Symbol()];
```

`integers` 中的元素都是 number 类型的，而 `items` 中的元素类型很多。

尽管如此，我们还是建议在数组中使用单一类型，这样更好调试。

## 1.2. 创建

1. 数组字面量

数组字面量是创建数组最常使用，也是最便捷的方式。

2. Array 构造函数

使用 Array 构造函数也可以创建数组。

当给 Array 构造函数传进一个正整数时，得到的数组的 length 就是这个正整数，且每个元素都为 undefined。

```javascript
const threeEmpties = new Array(3);
console.log(threeEmpties);
// -> [ <3 empty items> ]
```

但是，给 Array 构造函数传进去 2 个会发生什么呢？

```javascript
const confusedArray = new Array(3, 3);
console.log(confusedArray);
// -> [3, 3]
```

可以看到，传进去的正整数数量超过一个时，Array 构造函数会识别为元素，而不是数组的长度。

对于其他类型的元素也一样：

```javascript
const fruits = ['orange', 'watermelon', 'strawberry'];
console.log(fruits);
// -> [ 'orange', 'watermelon', 'strawberry' ]
```

我们推荐在大多数情况下使用数组字面量来创建数组。

## 1.3. 填充

## 1.4. 判定和转换

## 1.5. 查看

查看数组的元素非常简单，使用中括号，并传进去元素对应的索引即可。

```javascript
const fruits = ['orange', 'watermelon', 'strawberry'];
console.log(fruits[0]);
// -> 'orange'
```

值得注意的是，在 JavaScript 中，索引是从 0 开始的，并且不允许负整数索引。

```javascript
const fruits = ['orange', 'watermelon', 'strawberry'];
console.log(fruits[-1]);
// -> undefined
```

**实现负整数索引**

可是，我们可以使用 **代理(Proxy)** 让数组可以由负整数索引访问，一般的做法是当我们访问 -1 时，返回最后一个元素，也就是索引为 `length - 1` 的元素。同理，对于 -n 索引的元素，就返回 `length - n` 索引的元素。

```javascript
let fruits = ['orange', 'watermelon', 'strawberry'];
fruits = new Proxy(fruits, {
  get(array, indexString) {
    const index = parseInt(indexString);

    if (index < 0) {
      return array[array.length + index];
    }
    return array[index];
  },
});

console.log(fruits[-1]);
// -> 'strawberry'
```

同理，我们也可以实现新的 Array.prototype.at(index) 方法 (这个方法实际上已经被较新的浏览器实现 Chrome v90+ 或 Nodejs v16.6.0+)。

```javascript
const fruits = ['orange', 'watermelon', 'strawberry'];
Array.prototype.at =
  Array.prototype.at ||
  function at(index) {
    if (index < 0) {
      return this[this.length + index];
    }
    return this[index];
  };

console.log(fruits.at(-1));
// -> 'strawberry'
```

## 1.6. 搜索

## 1.7. 增添，删除和替换

JavaScript 提供了很多的内置操作数组元素的方法。

### 1.7.1. splice

Array.prototype.splice(index, deleteCount, ...items) 方法是一个强大的数组原型方法，用它可以对数组内的元素进行增添，删除或者替换操作。

这个方法的第 1 个参数是要进行操作的元素索引，第 2 个参数是要删除的的元素的个数(删除操作包含 index 索引的元素，并前往后)，剩下的参数是要添加的元素(添加操作从 index 索引元素往前，和删除操作顺序相反)。

这个方法的返回值永远是被删除的元素组成的数组，如果没有删除元素，则返回空数组。

```javascript
const fruits = ['orange', 'watermelon', 'strawberry'];

// 向数组末尾添加元素 'apple'
fruits.splice(fruits.length, 0, 'apple');
console.log(fruits);
// -> [ 'orange', 'watermelon', 'strawberry', 'apple' ]

// 将 'apple' 元素替换为 'pear'
fruits.splice(fruits.length - 1, 1, 'pear');
console.log(fruits);
// -> [ 'orange', 'watermelon', 'strawberry', 'pear' ]

// 将 'pear' 元素删除
fruits.splice(fruits.length - 1, 1);
console.log(fruits);
// -> [ 'orange', 'watermelon', 'strawberry' ]
```

### 1.7.2. 实现 insert, update, remove 方法

我们可以使用 splice 方法，打造出更为便捷的 insert，update，remove(不叫 delete 的原因是 delete 是一个关键字) 方法。这些方法返回值为该变后的数组，这样我们便可以 **连锁调用**。

1. insert(index, ...items)

```javascript
const fruits = ['orange', 'watermelon', 'strawberry'];

Array.prototype.insert = function insert(index, ...items) {
  this.splice(index, 0, ...items);
  return this;
};

fruits.insert(fruits.length, 'apple');
console.log(fruits);
// -> [ 'orange', 'watermelon', 'strawberry', 'apple' ]
```

2. update(index, ...items)

```javascript
const fruits = ['orange', 'watermelon', 'strawberry', 'apple'];

Array.prototype.update = function update(index, ...items) {
  this.splice(index, 1, ...items);
  return this;
};

fruits.update(fruits.length - 1, 'pear');
console.log(fruits);
// -> [ 'orange', 'watermelon', 'strawberry', 'pear' ]
```

3. remove(index, removeCount)

```javascript
const fruits = ['orange', 'watermelon', 'strawberry', 'pear'];

Array.prototype.remove = function remove(index, removeCount) {
  this.splice(index, removeCount);
  return this;
};

fruits.remove(fruits.length - 1, 1);
console.log(fruits);
// -> [ 'orange', 'watermelon', 'strawberry' ]
```

这 3 个方法可以连锁调用，因为每次方法被调用后都返回改变后的数组。

```javascript
// ...
const fruits = ['orange', 'watermelon', 'strawberry'];
fruits
  .insert(fruits.length, 'apple')
  .update(fruits.length - 1, 'pear')
  .remove(fruits.length - 1, 1);

console.log(fruits);
// -> [ 'orange', 'watermelon', 'strawberry' ]
```

## 1.8. 复制和切片

使用 Array.prototype.slice(startIndex, endIndex) 方法可以便捷的复制数组元素。

这个方法接收 2 个参数，分别表示开始索引和结束索引。

返回值为开始索引和结束索引(不包含结束索引)之间值(对于原始值)或引用(对于广义的对象)的复制组成的数组。

当不传任何参数时，startIndex 为 0，endIndex 为数组末尾索引。

```javascript
const fruits = ['orange', 'watermelon', 'strawberry'];

// 当不传进任何参数时
const fruitsCopy = fruits.slice();

console.log(fruitsCopy);
// -> [ 'orange', 'watermelon', 'strawberry' ]
```

不传 endIndex 默认为数组末尾索引。

```javascript
const fruits = ['orange', 'watermelon', 'strawberry'];

// 当不传进任何参数时
const fruitsPartCopy = fruits.slice(1);

console.log(fruitsPartCopy);
// -> [ 'watermelon', 'strawberry' ]
```

传进 startIndex 和 endIndex，则就是指定值。

```javascript
const fruits = ['orange', 'watermelon', 'strawberry'];

// 当不传进任何参数时
const fruitsPartCopy = fruits.slice(1, 2);

console.log(fruitsPartCopy);
// -> [ 'watermelon']
```

值得注意的是，对于广义对象类型的元素，复制的是引用。

```javascript
const obj1 = {id: 'obj1'};
const obj2 = {id: 'obj2'};

const objs = [obj1, obj2];
const objsCopy = objs.slice();

// 该变副本第1个元素的 id，理应不会对原始数组产生影响
objsCopy[0].id = 'changed';

// 但是实际产生了影响
console.log(objs);
// -> [ { id: 'changed' }, { id: 'obj2' } ]
```

## 1.9. 迭代

## 1.10. 排序和乱序
