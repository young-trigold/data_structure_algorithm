## 1. 简介

要存储多个元素，数组（或列表）可能是最常用的数据结构。正如本书之前提到的，每种语言都实现了数组。这种数据结构非常方便，提供了一个便利的[]语法来访问其元素。然而，这种数据结构有一个缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。（尽管我们已经学过，JavaScript 有来自Array 类的方法可以帮我们做这些事，但背后的情况同样如此。）

链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。

相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。在数组中，我们可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，则需要从起点（表头）开始迭代链表直到找到所需的元素。

现实中也有一些链表的例子。第一个例子就是康加舞队。每个人是一个元素，手就是链向下一个人的指针。可以向队列中增加人——只需要找到想加入的点，断开连接，插入一个人，再重新连接起来。

另一个例子是寻宝游戏。你有一条线索，这条线索就是指向寻找下一条线索的地点的指针。你顺着这条链接去下一个地点，得到另一条指向再下一处的线索。得到链表中间的线索的唯一办法，就是从起点（第一条线索）顺着链表寻找。

还有一个可能是用来说明链表的最流行的例子，那就是火车。一列火车是由一系列车厢（也称车皮）组成的。每节车厢或车皮都相互连接。你很容易分离一节车皮，改变它的位置、添加或移除它。

### 1.1. 实现

```javascript
// Node 辅助类
class Node {
  constructor(element) {
    this.element = element;
    this.next = null;
  }
}

const LinkedList = (() => {
  // 封装私有属性
  const store = new WeakMap();

  class LinkedList {
    constructor() {
      store.set(this, { _count: 0 });
      this.head = null;
    }

    // 长度 只读
    get size() {
      return store.get(this)._count;
    }

    // 是否为空 只读
    get isEmpty() {
      return this.size === 0;
    }

    // 在链表末尾添加一个元素
    append(element) {
      const newNode = new Node(element);

      if (this.isEmpty) {
        this.head = newNode;
      } else {
        this.getNodeAt(this.size - 1).next = newNode;
      }

      store.get(this)._count += 1;

      return this;
    }

    // 在位置 index 处添加一个元素
    insert(element, index) {
      const newNode = new Node(element);

      if (index === 0) {
        newNode.next = this.head;
        this.head = newNode;
      }

      if (index >= 1 && index <= this.size) {
        newNode.next = this.getNodeAt(index);
        this.getNodeAt(index - 1).next = newNode;
      }

      store.get(this)._count += 1;
    }

    // 获取 index 位置处的节点
    getNodeAt(index) {
      if (index >= 0 && index < this.size) {
        let curNode = this.head;
        let i = 0;

        while (i < index) {
          curNode = curNode.next;
          i += 1;
        }

        return curNode;
      }

      return null;
    }

    // 移除位置 index 处的元素
    removeAt(index) {
      if (index === 0) {
        const originHeadElement = this.head?.element;
        this.head = this.getNodeAt(1);
        return originHeadElement;
      }

      if (index >= 1 && index < this.size) {
        const elementToRemove = this.getNodeAt(index).element;
        this.getNodeAt(index - 1).next = this.getNodeAt(index + 1);
        return elementToRemove;
      }

      return null;
    }

    // 移除元素
    remove(element) {
      return this.removeAt(this.indexOf(element));
    }

    // 返回指定元素的位置
    indexOf(element) {
      let curNode = this.head;
      let i = 0;

      while (curNode) {
        if (curNode.element === element) {
          return i;
        }

        curNode = curNode.next;
        i += 1;
      }

      return -1;
    }

    // 默认迭代器用于展示所有元素
    [Symbol.iterator]() {
      let curNode = this.head;

      return {
        next: () => {
          const result = { value: curNode?.element, done: curNode === null };
          curNode = curNode?.next;
          return result;
        },
        [Symbol.iterator]() {
          return this;
        },
      };
    }
  }

  return LinkedList;
})();
```

### 1.2. 使用链表

```javascript
const linkedList = new LinkedList();
linkedList.append('apple').append('orange').append('pear');
console.log(...linkedList);
// -> 'apple' 'orange' 'pear'

linkedList.insert('watermelon', 3);
console.log(...linkedList);
// -> 'apple' 'orange' 'pear' 'watermelon'

console.log(linkedList.indexOf('watermelon'));
// -> 3

console.log(linkedList.getNodeAt(3).element);
// -> 'watermelon'

linkedList.removeAt(3);
console.log(...linkedList);
// -> 'apple' 'orange' 'pear'

linkedList.remove('apple');
console.log(...linkedList);
// -> 'orange' 'pear'
```

